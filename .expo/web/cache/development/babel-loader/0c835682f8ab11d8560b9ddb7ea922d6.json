{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { EventEmitter, UnavailabilityError, Platform } from 'expo-modules-core';\nimport ExpoClipboard from \"./ExpoClipboard\";\nvar emitter = new EventEmitter(ExpoClipboard);\nvar onClipboardEventName = 'onClipboardChanged';\nexport function getStringAsync() {\n  var options,\n      _args = arguments;\n  return _regeneratorRuntime.async(function getStringAsync$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};\n\n          if (ExpoClipboard.getStringAsync) {\n            _context.next = 3;\n            break;\n          }\n\n          throw new UnavailabilityError('Clipboard', 'getStringAsync');\n\n        case 3:\n          _context.next = 5;\n          return _regeneratorRuntime.awrap(ExpoClipboard.getStringAsync(options));\n\n        case 5:\n          return _context.abrupt(\"return\", _context.sent);\n\n        case 6:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function setStringAsync(text) {\n  var options,\n      _args2 = arguments;\n  return _regeneratorRuntime.async(function setStringAsync$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n\n          if (ExpoClipboard.setStringAsync) {\n            _context2.next = 3;\n            break;\n          }\n\n          throw new UnavailabilityError('Clipboard', 'setStringAsync');\n\n        case 3:\n          return _context2.abrupt(\"return\", ExpoClipboard.setStringAsync(text, options));\n\n        case 4:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function setString(text) {\n  if (Platform.OS === 'web') {\n    return ExpoClipboard.setString(text);\n  } else {\n    setStringAsync(text);\n  }\n}\nexport function hasStringAsync() {\n  if (!ExpoClipboard.hasStringAsync) {\n    throw new UnavailabilityError('Clipboard', 'hasStringAsync');\n  }\n\n  return ExpoClipboard.hasStringAsync();\n}\nexport function getUrlAsync() {\n  return _regeneratorRuntime.async(function getUrlAsync$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          if (ExpoClipboard.getUrlAsync) {\n            _context3.next = 2;\n            break;\n          }\n\n          throw new UnavailabilityError('Clipboard', 'getUrlAsync');\n\n        case 2:\n          _context3.next = 4;\n          return _regeneratorRuntime.awrap(ExpoClipboard.getUrlAsync());\n\n        case 4:\n          return _context3.abrupt(\"return\", _context3.sent);\n\n        case 5:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function setUrlAsync(url) {\n  return _regeneratorRuntime.async(function setUrlAsync$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          if (ExpoClipboard.setUrlAsync) {\n            _context4.next = 2;\n            break;\n          }\n\n          throw new UnavailabilityError('Clipboard', 'setUrlAsync');\n\n        case 2:\n          return _context4.abrupt(\"return\", ExpoClipboard.setUrlAsync(url));\n\n        case 3:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function hasUrlAsync() {\n  return _regeneratorRuntime.async(function hasUrlAsync$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          if (ExpoClipboard.hasUrlAsync) {\n            _context5.next = 2;\n            break;\n          }\n\n          throw new UnavailabilityError('Clipboard', 'hasUrlAsync');\n\n        case 2:\n          _context5.next = 4;\n          return _regeneratorRuntime.awrap(ExpoClipboard.hasUrlAsync());\n\n        case 4:\n          return _context5.abrupt(\"return\", _context5.sent);\n\n        case 5:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function getImageAsync(options) {\n  return _regeneratorRuntime.async(function getImageAsync$(_context6) {\n    while (1) {\n      switch (_context6.prev = _context6.next) {\n        case 0:\n          if (ExpoClipboard.getImageAsync) {\n            _context6.next = 2;\n            break;\n          }\n\n          throw new UnavailabilityError('Clipboard', 'getImageAsync');\n\n        case 2:\n          _context6.next = 4;\n          return _regeneratorRuntime.awrap(ExpoClipboard.getImageAsync(options));\n\n        case 4:\n          return _context6.abrupt(\"return\", _context6.sent);\n\n        case 5:\n        case \"end\":\n          return _context6.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function setImageAsync(base64Image) {\n  return _regeneratorRuntime.async(function setImageAsync$(_context7) {\n    while (1) {\n      switch (_context7.prev = _context7.next) {\n        case 0:\n          if (ExpoClipboard.setImageAsync) {\n            _context7.next = 2;\n            break;\n          }\n\n          throw new UnavailabilityError('Clipboard', 'setImageAsync');\n\n        case 2:\n          return _context7.abrupt(\"return\", ExpoClipboard.setImageAsync(base64Image));\n\n        case 3:\n        case \"end\":\n          return _context7.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function hasImageAsync() {\n  return _regeneratorRuntime.async(function hasImageAsync$(_context8) {\n    while (1) {\n      switch (_context8.prev = _context8.next) {\n        case 0:\n          if (ExpoClipboard.hasImageAsync) {\n            _context8.next = 2;\n            break;\n          }\n\n          throw new UnavailabilityError('Clipboard', 'hasImageAsync');\n\n        case 2:\n          return _context8.abrupt(\"return\", ExpoClipboard.hasImageAsync());\n\n        case 3:\n        case \"end\":\n          return _context8.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\nexport function addClipboardListener(listener) {\n  var listenerWrapper = function listenerWrapper(event) {\n    var wrappedEvent = _objectSpread(_objectSpread({}, event), {}, {\n      get content() {\n        console.warn(\"The 'content' property of the clipboard event is deprecated. Use 'getStringAsync()' instead to get clipboard content\");\n        return '';\n      }\n\n    });\n\n    listener(wrappedEvent);\n  };\n\n  return emitter.addListener(onClipboardEventName, listenerWrapper);\n}\nexport function removeClipboardListener(subscription) {\n  emitter.removeSubscription(subscription);\n}\nexport * from \"./Clipboard.types\";","map":{"version":3,"mappings":"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","names":["EventEmitter","UnavailabilityError","Platform","ExpoClipboard","emitter","onClipboardEventName","getStringAsync","options","setStringAsync","text","setString","OS","hasStringAsync","getUrlAsync","setUrlAsync","url","hasUrlAsync","getImageAsync","setImageAsync","base64Image","hasImageAsync","addClipboardListener","listener","listenerWrapper","event","wrappedEvent","content","console","warn","addListener","removeClipboardListener","subscription","removeSubscription"],"sourceRoot":"","sources":["../src/Clipboard.ts"],"sourcesContent":["import { EventEmitter, Subscription, UnavailabilityError, Platform } from 'expo-modules-core';\n\nimport {\n  ClipboardImage,\n  ContentType,\n  GetImageOptions,\n  GetStringOptions,\n  SetStringOptions,\n} from './Clipboard.types';\nimport ExpoClipboard from './ExpoClipboard';\n\nconst emitter = new EventEmitter(ExpoClipboard);\n\nconst onClipboardEventName = 'onClipboardChanged';\n\ntype ClipboardEvent = {\n  /**\n   * @deprecated Returns empty string. Use [`getStringAsync()`](#getstringasyncoptions) instead to retrieve clipboard content.\n   */\n  content: string;\n  /**\n   * An array of content types that are available on the clipboard.\n   */\n  contentTypes: ContentType[];\n};\n\nexport { Subscription, ClipboardEvent };\n\n/**\n * Gets the content of the user's clipboard. Please note that calling this method on web will prompt\n * the user to grant your app permission to \"see text and images copied to the clipboard.\"\n *\n * @param options Options for the clipboard content to be retrieved.\n * @returns A promise that resolves to the content of the clipboard.\n */\nexport async function getStringAsync(options: GetStringOptions = {}): Promise<string> {\n  if (!ExpoClipboard.getStringAsync) {\n    throw new UnavailabilityError('Clipboard', 'getStringAsync');\n  }\n  return await ExpoClipboard.getStringAsync(options);\n}\n\n/**\n * Sets the content of the user's clipboard.\n *\n * @param text The string to save to the clipboard.\n * @param options Options for the clipboard content to be set.\n * @returns On web, this returns a promise that fulfills to a boolean value indicating whether or not\n * the string was saved to the user's clipboard. On iOS and Android, the promise always resolves to `true`.\n */\nexport async function setStringAsync(\n  text: string,\n  options: SetStringOptions = {}\n): Promise<boolean> {\n  if (!ExpoClipboard.setStringAsync) {\n    throw new UnavailabilityError('Clipboard', 'setStringAsync');\n  }\n  return ExpoClipboard.setStringAsync(text, options);\n}\n\n/**\n * Sets the content of the user's clipboard.\n * @deprecated Use [`setStringAsync()`](#setstringasynctext-options) instead.\n *\n * @returns On web, this returns a boolean value indicating whether or not the string was saved to\n * the user's clipboard. On iOS and Android, nothing is returned.\n */\nexport function setString(text: string): void {\n  if (Platform.OS === 'web') {\n    // on web, we need to return legacy method,\n    // because of different return type\n    return ExpoClipboard.setString(text);\n  } else {\n    setStringAsync(text);\n  }\n}\n\n/**\n * Returns whether the clipboard has text content. Returns true for both plain text and rich text (e.g. HTML).\n *\n * On web, this requires the user to grant your app permission to _\"see text and images copied to the clipboard\"_.\n *\n * @returns A promise that fulfills to `true` if clipboard has text content, resolves to `false` otherwise.\n */\nexport function hasStringAsync(): Promise<boolean> {\n  if (!ExpoClipboard.hasStringAsync) {\n    throw new UnavailabilityError('Clipboard', 'hasStringAsync');\n  }\n  return ExpoClipboard.hasStringAsync();\n}\n\n/**\n * Gets the URL from the user's clipboard.\n *\n * @returns A promise that fulfills to the URL in the clipboard.\n * @platform iOS\n */\nexport async function getUrlAsync(): Promise<string | null> {\n  if (!ExpoClipboard.getUrlAsync) {\n    throw new UnavailabilityError('Clipboard', 'getUrlAsync');\n  }\n  return await ExpoClipboard.getUrlAsync();\n}\n\n/**\n * Sets a URL in the user's clipboard.\n *\n * @param url The URL to save to the clipboard.\n * @platform iOS\n */\nexport async function setUrlAsync(url: string): Promise<void> {\n  if (!ExpoClipboard.setUrlAsync) {\n    throw new UnavailabilityError('Clipboard', 'setUrlAsync');\n  }\n  return ExpoClipboard.setUrlAsync(url);\n}\n\n/**\n * Returns whether the clipboard has a URL content.\n *\n * @returns A promise that fulfills to `true` if clipboard has URL content, resolves to `false` otherwise.\n * @platform iOS\n */\nexport async function hasUrlAsync(): Promise<boolean> {\n  if (!ExpoClipboard.hasUrlAsync) {\n    throw new UnavailabilityError('Clipboard', 'hasUrlAsync');\n  }\n  return await ExpoClipboard.hasUrlAsync();\n}\n\n/**\n * Gets the image from the user's clipboard and returns it in the specified format. Please note that calling\n * this method on web will prompt the user to grant your app permission to \"see text and images copied to the clipboard.\"\n *\n * @param options A `GetImageOptions` object to specify the desired format of the image.\n * @returns If there was an image in the clipboard, the promise resolves to\n * a [`ClipboardImage`](#clipboardimage) object containing the base64 string and metadata of the image.\n * Otherwise, it resolves to `null`.\n *\n * @example\n * ```tsx\n * const img = await Clipboard.getImageAsync({ format: 'png' });\n * // ...\n * <Image source={{ uri: img?.data }} style={{ width: 200, height: 200 }} />\n * ```\n */\nexport async function getImageAsync(options: GetImageOptions): Promise<ClipboardImage | null> {\n  if (!ExpoClipboard.getImageAsync) {\n    throw new UnavailabilityError('Clipboard', 'getImageAsync');\n  }\n  return await ExpoClipboard.getImageAsync(options);\n}\n\n/**\n * Sets an image in the user's clipboard.\n *\n * @param base64Image Image encoded as a base64 string, without MIME type.\n *\n * @example\n * ```tsx\n * const result = await ImagePicker.launchImageLibraryAsync({\n *   mediaTypes: ImagePicker.MediaTypeOptions.Images,\n *   base64: true,\n * });\n * await Clipboard.setImageAsync(result.base64);\n * ```\n */\nexport async function setImageAsync(base64Image: string): Promise<void> {\n  if (!ExpoClipboard.setImageAsync) {\n    throw new UnavailabilityError('Clipboard', 'setImageAsync');\n  }\n  return ExpoClipboard.setImageAsync(base64Image);\n}\n\n/**\n * Returns whether the clipboard has a image content.\n *\n * On web, this requires the user to grant your app permission to _\"see text and images copied to the clipboard\"_.\n *\n * @returns A promise that fulfills to `true` if clipboard has image content, resolves to `false` otherwise.\n */\nexport async function hasImageAsync(): Promise<boolean> {\n  if (!ExpoClipboard.hasImageAsync) {\n    throw new UnavailabilityError('Clipboard', 'hasImageAsync');\n  }\n  return ExpoClipboard.hasImageAsync();\n}\n\n/**\n * Adds a listener that will fire whenever the content of the user's clipboard changes. This method\n * is a no-op on Web.\n *\n * @param listener Callback to execute when listener is triggered. The callback is provided a\n * single argument that is an object containing information about clipboard contents.\n *\n * @example\n * ```typescript\n * Clipboard.addClipboardListener(({ contentTypes }: ClipboardEvent) => {\n *   if (contentTypes.includes(Clipboard.ContentType.PLAIN_TEXT)) {\n *     Clipboard.getStringAsync().then(content => {\n *       alert('Copy pasta! Here\\'s the string that was copied: ' + content)\n *     });\n *   } else if (contentTypes.includes(Clipboard.ContentType.IMAGE)) {\n *     alert('Yay! Clipboard contains an image');\n *   }\n * });\n * ```\n */\nexport function addClipboardListener(listener: (event: ClipboardEvent) => void): Subscription {\n  // TODO: Get rid of this wrapper once we remove deprecated `content` property (not before SDK47)\n  const listenerWrapper = (event: ClipboardEvent) => {\n    const wrappedEvent: ClipboardEvent = {\n      ...event,\n      get content(): string {\n        console.warn(\n          \"The 'content' property of the clipboard event is deprecated. Use 'getStringAsync()' instead to get clipboard content\"\n        );\n        return '';\n      },\n    };\n    listener(wrappedEvent);\n  };\n  return emitter.addListener<ClipboardEvent>(onClipboardEventName, listenerWrapper);\n}\n\n/**\n * Removes the listener added by addClipboardListener. This method is a no-op on Web.\n *\n * @param subscription The subscription to remove (created by addClipboardListener).\n *\n * @example\n * ```typescript\n * const subscription = addClipboardListener(() => {\n *   alert('Copy pasta!');\n * });\n * removeClipboardListener(subscription);\n * ```\n */\nexport function removeClipboardListener(subscription: Subscription) {\n  emitter.removeSubscription(subscription);\n}\n\nexport * from './Clipboard.types';\n"]},"metadata":{},"sourceType":"module"}